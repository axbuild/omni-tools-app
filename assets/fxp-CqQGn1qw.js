const C=":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD",T=C+"\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040",N="["+C+"]["+T+"]*",w=new RegExp("^"+N+"$");function k(e,n){const r=[];let u=n.exec(e);for(;u;){const s=[];s.startIndex=n.lastIndex-u[0].length;const t=u.length;for(let d=0;d<t;d++)s.push(u[d]);r.push(s),u=n.exec(e)}return r}const S=function(e){const n=w.exec(e);return!(n===null||typeof n>"u")};function V(e){return typeof e<"u"}const P={allowBooleanAttributes:!1,unpairedTags:[]};function a(e,n){n=Object.assign({},P,n);const r=[];let u=!1,s=!1;e[0]==="\uFEFF"&&(e=e.substr(1));for(let t=0;t<e.length;t++)if(e[t]==="<"&&e[t+1]==="?"){if(t+=2,t=A(e,t),t.err)return t}else if(e[t]==="<"){let d=t;if(t++,e[t]==="!"){t=F(e,t);continue}else{let p=!1;e[t]==="/"&&(p=!0,t++);let i="";for(;t<e.length&&e[t]!==">"&&e[t]!==" "&&e[t]!=="	"&&e[t]!==`
`&&e[t]!=="\r";t++)i+=e[t];if(i=i.trim(),i[i.length-1]==="/"&&(i=i.substring(0,i.length-1),t--),!L(i)){let f;return i.trim().length===0?f="Invalid space after '<'.":f="Tag '"+i+"' is an invalid name.",o("InvalidTag",f,g(e,t))}const v=O(e,t);if(v===!1)return o("InvalidAttr","Attributes for '"+i+"' have open quote.",g(e,t));let l=v.value;if(t=v.index,l[l.length-1]==="/"){const f=t-l.length;l=l.substring(0,l.length-1);const c=I(l,n);if(c===!0)u=!0;else return o(c.err.code,c.err.msg,g(e,f+c.err.line))}else if(p)if(v.tagClosed){if(l.trim().length>0)return o("InvalidTag","Closing tag '"+i+"' can't have attributes or invalid starting.",g(e,d));if(r.length===0)return o("InvalidTag","Closing tag '"+i+"' has not been opened.",g(e,d));{const f=r.pop();if(i!==f.tagName){let c=g(e,f.tagStartPos);return o("InvalidTag","Expected closing tag '"+f.tagName+"' (opened in line "+c.line+", col "+c.col+") instead of closing tag '"+i+"'.",g(e,d))}r.length==0&&(s=!0)}}else return o("InvalidTag","Closing tag '"+i+"' doesn't have proper closing.",g(e,t));else{const f=I(l,n);if(f!==!0)return o(f.err.code,f.err.msg,g(e,t-l.length+f.err.line));if(s===!0)return o("InvalidXml","Multiple possible root nodes found.",g(e,t));n.unpairedTags.indexOf(i)!==-1||r.push({tagName:i,tagStartPos:d}),u=!0}for(t++;t<e.length;t++)if(e[t]==="<")if(e[t+1]==="!"){t++,t=F(e,t);continue}else if(e[t+1]==="?"){if(t=A(e,++t),t.err)return t}else break;else if(e[t]==="&"){const f=R(e,t);if(f==-1)return o("InvalidChar","char '&' is not expected.",g(e,t));t=f}else if(s===!0&&!b(e[t]))return o("InvalidXml","Extra text at the end",g(e,t));e[t]==="<"&&t--}}else{if(b(e[t]))continue;return o("InvalidChar","char '"+e[t]+"' is not expected.",g(e,t))}if(u){if(r.length==1)return o("InvalidTag","Unclosed tag '"+r[0].tagName+"'.",g(e,r[0].tagStartPos));if(r.length>0)return o("InvalidXml","Invalid '"+JSON.stringify(r.map(t=>t.tagName),null,4).replace(/\r?\n/g,"")+"' found.",{line:1,col:1})}else return o("InvalidXml","Start tag expected.",1);return!0}function b(e){return e===" "||e==="	"||e===`
`||e==="\r"}function A(e,n){const r=n;for(;n<e.length;n++)if(e[n]=="?"||e[n]==" "){const u=e.substr(r,n-r);if(n>5&&u==="xml")return o("InvalidXml","XML declaration allowed only at the start of the document.",g(e,n));if(e[n]=="?"&&e[n+1]==">"){n++;break}else continue}return n}function F(e,n){if(e.length>n+5&&e[n+1]==="-"&&e[n+2]==="-"){for(n+=3;n<e.length;n++)if(e[n]==="-"&&e[n+1]==="-"&&e[n+2]===">"){n+=2;break}}else if(e.length>n+8&&e[n+1]==="D"&&e[n+2]==="O"&&e[n+3]==="C"&&e[n+4]==="T"&&e[n+5]==="Y"&&e[n+6]==="P"&&e[n+7]==="E"){let r=1;for(n+=8;n<e.length;n++)if(e[n]==="<")r++;else if(e[n]===">"&&(r--,r===0))break}else if(e.length>n+9&&e[n+1]==="["&&e[n+2]==="C"&&e[n+3]==="D"&&e[n+4]==="A"&&e[n+5]==="T"&&e[n+6]==="A"&&e[n+7]==="["){for(n+=8;n<e.length;n++)if(e[n]==="]"&&e[n+1]==="]"&&e[n+2]===">"){n+=2;break}}return n}const E='"',X="'";function O(e,n){let r="",u="",s=!1;for(;n<e.length;n++){if(e[n]===E||e[n]===X)u===""?u=e[n]:u!==e[n]||(u="");else if(e[n]===">"&&u===""){s=!0;break}r+=e[n]}return u!==""?!1:{value:r,index:n,tagClosed:s}}const y=new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`,"g");function I(e,n){const r=k(e,y),u={};for(let s=0;s<r.length;s++){if(r[s][1].length===0)return o("InvalidAttr","Attribute '"+r[s][2]+"' has no space in starting.",h(r[s]));if(r[s][3]!==void 0&&r[s][4]===void 0)return o("InvalidAttr","Attribute '"+r[s][2]+"' is without value.",h(r[s]));if(r[s][3]===void 0&&!n.allowBooleanAttributes)return o("InvalidAttr","boolean attribute '"+r[s][2]+"' is not allowed.",h(r[s]));const t=r[s][2];if(!B(t))return o("InvalidAttr","Attribute '"+t+"' is an invalid name.",h(r[s]));if(!u.hasOwnProperty(t))u[t]=1;else return o("InvalidAttr","Attribute '"+t+"' is repeated.",h(r[s]))}return!0}function M(e,n){let r=/\d/;for(e[n]==="x"&&(n++,r=/[\da-fA-F]/);n<e.length;n++){if(e[n]===";")return n;if(!e[n].match(r))break}return-1}function R(e,n){if(n++,e[n]===";")return-1;if(e[n]==="#")return n++,M(e,n);let r=0;for(;n<e.length;n++,r++)if(!(e[n].match(/\w/)&&r<20)){if(e[n]===";")break;return-1}return n}function o(e,n,r){return{err:{code:e,msg:n,line:r.line||r,col:r.col}}}function B(e){return S(e)}function L(e){return S(e)}function g(e,n){const r=e.substring(0,n).split(/\r?\n/);return{line:r.length,col:r[r.length-1].length+1}}function h(e){return e.startIndex+e[1].length}const j={validate:a};export{j as X,V as a,k as g,S as i,a as v};
